ğŸ—ï¸ Day 2: Improving SDLC with DevOps
Overview

On Day 2 of the "Zero to Hero" journey, we move from the philosophy of DevOps into its practical application within the Software Development Life Cycle (SDLC). Understanding SDLC is mandatory for any engineer because it provides the standardized framework that every organizationâ€”from startups to tech giantsâ€”uses to build software.
ğŸ“– The Narrative: Why SDLC?

Without a standardized process, software development is chaotic. Imagine a team trying to build an e-commerce feature (like a "Kids Section") without a plan. Developers might use the wrong database, or Testers might find critical bugs only after the product is live.

SDLC is the roadmap that ensures quality, and DevOps is the engine that makes that roadmap move faster.
ğŸ—ï¸ The 6 Phases of SDLC
1. Planning & Requirement Gathering ğŸ“

This is the "Discovery" phase. Business Analysts and Product Owners gather requirements from stakeholders and customers.

    Goal: Determine if the feature is actually needed.

    Example: Researching if example.com users would actually buy kids' clothes before writing a single line of code.

2. Defining ğŸ“‘

Once the plan is set, requirements are clearly defined in a Software Requirement Specification (SRS) document. This serves as the "source of truth" for the entire project.
3. Designing ğŸ¨

Architects create the blueprints for the software. This is divided into:

    HLD (High-Level Design): Focuses on system architecture, database choice, and scalability.

    LLD (Low-Level Design): Focuses on specific logic, function calls, and code modules.

4. Building (Developing) ğŸ’»

This is where developers write the actual code based on the design documents.

    Collaboration: Developers use Git to push their code to a centralized repository so the team can work together.

5. Testing ğŸ§ª

The Quality Assurance (QA) team takes the code and deploys it in a staging environment.

    Goal: Ensure the code matches the SRS and is bug-free.

6. Deployment ğŸš€

The final stage where the software is promoted to the Production Server so the end-user (the customer) can finally use it.
ğŸ› ï¸ The DevOps Battleground: Automation & Efficiency

As a DevOps Engineer, your primary focus is on Phase 4 (Build), Phase 5 (Test), and Phase 6 (Deploy).

While others handle the planning or design, the DevOps Engineer is responsible for:

    Automating the Build: Ensuring code is automatically compiled and stored when a developer pushes to Git.

    Automating Testing: Triggering automated test suites so bugs are caught instantly.

    Automating Deployment: Using scripts (CI/CD) to push code to servers without any manual, human error.

    Key Learning: A DevOps Engineer does not necessarily write the application code or do the manual testing. Instead, they automate the pipeline so that the code moves through these phases with zero manual intervention.

ğŸ’¡ Key Takeaways

    Standards Matter: SDLC is the industry-accepted standard for software quality.

    DevOps = Speed + Reliability: We apply DevOps to SDLC to shorten the feedback loop.

    Agile over Waterfall: Modern teams use Agile, performing these phases in short, iterative "Sprints" rather than waiting months for a single release.
